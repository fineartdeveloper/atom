'use strict';var _asyncToGenerator = _interopRequireDefault(require('async-to-generator'));var _MIProxy;













function _load_MIProxy() {return _MIProxy = _interopRequireDefault(require('../lib/MIProxy'));}var _MIRecord;
function _load_MIRecord() {return _MIRecord = require('../lib/MIRecord');}var _StackFrames;
function _load_StackFrames() {return _StackFrames = _interopRequireDefault(require('../lib/StackFrames'));}var _Variables;
function _load_Variables() {return _Variables = _interopRequireDefault(require('../lib/Variables'));}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

class MockStackFrames extends (_StackFrames || _load_StackFrames()).default {
  stackFrameByHandle(handle) {
    return {
      threadId: 1,
      frameIndex: 0 };

  }} /**
      * Copyright (c) 2017-present, Facebook, Inc.
      * All rights reserved.
      *
      * This source code is licensed under the BSD-style license found in the
      * LICENSE file in the root directory of this source tree. An additional grant
      * of patent rights can be found in the PATENTS file in the same directory.
      *
      * 
      * @format
      */ // The mock class emulates the MI behavior of stack-list-variables
class MIProxyMock extends (_MIProxy || _load_MIProxy()).default {

  constructor() {
    super();this._nextVar = 1;this._vars = new Map();
  }

  sendCommand(command) {var _this = this;return (0, _asyncToGenerator.default)(function* () {
      let result = new (_MIRecord || _load_MIRecord()).MIResultRecord(
      null,
      { msg: `Invalid command "${command}"` },
      'error');


      const match = command.match(/^([^ ]+) *(.*)$/);

      if (match != null) {
        const [, op, args] = match;

        if (op === 'stack-list-variables') {
          const listArgs = args.match(
          /^--thread ([0-9]+) --frame ([0-9]+) --no-values$/);

          if (listArgs != null) {
            const vars = {
              variables: [
              { name: 'intval', value: '42', type: 'int' },
              { name: 'structval', type: 'mystruct' }] };



            result = new (_MIRecord || _load_MIRecord()).MIResultRecord(null, vars, 'done');
          }
        } else if (op === 'var-create') {
          const varCreateArgs = args.match(
          /^--thread ([0-9]+) --frame ([0-9]+) - [@*] (.*)$/);

          if (varCreateArgs != null) {
            const [, thread,, exp] = varCreateArgs;
            const name = `var${_this._nextVar++}`;
            const created = {
              name,
              numchild: '0',
              value: exp === 'intval' ? '42' : '...',
              type: exp === 'intval' ? 'int' : 'mystruct',
              'thread-id': thread,
              has_more: '0' };


            _this._vars.set(created.name, {
              value: created.value,
              type: created.type });


            result = new (_MIRecord || _load_MIRecord()).MIResultRecord(null, created, 'done');
          }
        } else if (op === 'var-evaluate-expression') {
          const value = _this._vars.get(args);
          const body = {
            value: value == null ? '??' : value.value };


          result = new (_MIRecord || _load_MIRecord()).MIResultRecord(null, body, 'done');
        } else if (op === 'var-info-type') {
          const value = _this._vars.get(args);
          const body = {
            type: value == null ? '??' : value.type };


          result = new (_MIRecord || _load_MIRecord()).MIResultRecord(null, body, 'done');
        }
      }

      return result;})();
  }}


describe('Variables', () => {
  let proxy;
  let stackFrames;
  let variables;

  beforeEach(() => {
    proxy = new MIProxyMock();
    stackFrames = new MockStackFrames(proxy);
    variables = new (_Variables || _load_Variables()).default(proxy, stackFrames);
  });

  it('getVariables() should return variables', done => {
    const varref = variables.variableReferenceForStackFrame(1000);
    variables.
    getVariables(varref).
    then(vars => {
      expect(vars.length).toBe(2);

      expect(vars[0].name).toBe('intval');
      expect(vars[0].type).toBe('int');
      expect(vars[0].value).toBe('42');
      expect(vars[0].variablesReference).toBe(0);

      expect(vars[1].name).toBe('structval');
      expect(vars[1].type).toBe('mystruct');
      expect(vars[1].value).toBe('...');

      // $$TODO when indexed variables are supported
      // expect(vars[1].variablesReference !== 0).toBeTruthy();

      // $FlowFixMe
      done();
    }).
    catch(error => {
      expect(true).toBe(false, error.message);
      // $FlowFixMe
      done();
    });
  });
});