{"version":3,"file":"expression-manager.js","sourceRoot":"","sources":["../../src/debug-area/expression-manager.ts"],"names":[],"mappings":"AAAA,WAAW,CAAA;AAgBX,MAAM;IAIJ;QAFQ,gBAAW,GAAgB,EAAE,CAAA;IAErB,CAAC;IAEV,cAAc;QACnB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAA;IACzB,CAAC;IAED,0DAA0D;IAC1D,+CAA+C;IAC/C,0CAA0C;IAC1C,OAAO;IACP,IAAI;IAEJ,gBAAgB,CAAE,UAAsB;QACtC,MAAM,CAAC,IAAI,OAAO,CAAE,CAAC,OAAO,EAAE,MAAM;YAClC,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;YAChD,EAAE,CAAA,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACf,qDAAqD;gBACtD,oCAAoC;gBACnC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YACtB,CAAC;YACD,MAAM,CAAC,MAAM,CAAC,4BAA4B,CAAC,CAAA;QAC7C,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,aAAa,CAAE,IAAY,EAAE,OAAY;QACvC,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;YACjC,IAAI,UAAU,GAAG;gBACf,IAAI;gBACJ,OAAO;aACM,CAAA;YACf,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;YAC7C,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBACf,OAAO,CAAC,UAAU,CAAC,CAAA;YACrB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,0BAA0B,CAAC,CAAA;YACpC,CAAC;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;CACF","sourcesContent":["'use babel'\n/*!\n * XAtom Debug\n * Copyright(c) 2017 Williams Medina <williams.medinaa@gmail.com>\n * MIT Licensed\n */\n\nimport { EventEmitter }  from 'events'\n\nexport interface Expression {\n  text: string,\n  element: any\n}\n\nexport type Expressions = Array<Expression>\n\nexport class ExpressionManager {\n\n  private expressions: Expressions = []\n\n  constructor () {}\n\n  public getExpressions (): Expressions {\n    return this.expressions\n  }\n\n  // getExpressionsFromFile(filePath: String): Expressions {\n  //   return this.expressions.filter((item) => {\n  //     return (item.filePath === filePath)\n  //   })\n  // }\n\n  removeExpression (Expression: Expression): Promise<boolean> {\n    return new Promise ((resolve, reject) => {\n      let index = this.expressions.indexOf(Expression)\n      if(index != -1) {\n        // if (expression.marker) Expression.marker.destroy()\n      \t// this.expressions.splice(index, 1)\n        return resolve(true)\n      }\n      return reject('Expression does not exists')\n    })\n  }\n\n  addExpression (text: string, element: any): Promise<Expression> {\n    return new Promise((resolve, reject) => {\n      let expression = {\n        text,\n        element\n      } as Expression\n      let index = this.expressions.push(expression)\n      if (index > -1) {\n        resolve(expression)\n      } else {\n        reject('Unable to add Expression')\n      }\n    })\n  }\n}\n"]}