{
  ".source.css .meta.css": {
    "important": {
      "prefix": "im",
      "body": """
      important$0
      """,
    },
  },


  ".source.js": {
    "console.clear": {
      "prefix": "cls",
      "body": """
      console.clear();$0
      """,
    },
    "console.log": {
      "prefix": "log",
      "body": """
      console.log(${1:''})$0
      """,
    },
    "console.warn": {
      "prefix": "warn",
      "body": """
      console.warn(${1:''})$0
      """,
    },
    "console.error": {
      "prefix": "error",
      "body": """
      console.error(${1:''})$0
      """,
    },
    "console.info": {
      "prefix": "info",
      "body": """
      console.info(${1:''})$0
      """,
    },
    "console.group": {
      "prefix": "g-log",
      "body": """
      console.group(${1:''});
      ${2:}
      console.groupEnd();$0
      """,
    },
  },


  ".source.php": {
    "if function exists": {
      "prefix": "if-fne",
      "body": """
      if (function_exists('${1:funcName}')) {
        ${3:${1:funcName}(${2:});}
      \\}$0
      """,
    },
    "if function not exists": {
      "prefix": "if-fnne",
      "body": """
      if (!function_exists('${1:funcName}')) {
        function ${1:funcName}(${2:}) {
          ${3:}
        \\}
      \\}$0
      """,
    },

    "pr": {
      "prefix": "pr",
      "body": """
      echo '<pre>'; print_r(${1:\\$${2:value}}); echo '</pre>';
      """,
    },

    "function assignment": {
      "prefix": "fn",
      "body": """
      function ${1:func_name}(${2:\\$${3:value}}) {
        ${4:/* ... */}
      \\}
      """,
    },

    "anonymous function": {
      "prefix": "f",
      "body": """
      function (${1:\\$${2:value}}${3:}) {
        ${4:/* ... */}
      \\}
      """,
    },

    "public function funcName()": {
      "prefix": "ff",
      "body": """
      /**
      * ${1:Proxy dynamic properties onto methods.}
      *
      * @return mixed
      */
      ${2:public} function ${3:funcName}(${4:\\$${5:value}}) {
        ${6:/* ... */}
      \\}
      """,
    },
  },


  ".source.gfm": {
    "markup": {
      "prefix": "`",
      "body": """
      ```${1:js}
      ${2:}
      ```
      """,
    },
  },


  ".text.plain.null-grammar, .source.shell": {
    "/bin/zsh": {
      "prefix": "zsh",
      "body": """
      #!/bin/zsh$0
      """,
    },
    "/bin/bash": {
      "prefix": "bash",
      "body": """
      #!/bin/bash$0
      """,
    },
    "/bin/sh": {
      "prefix": "sh",
      "body": """
      #!/bin/sh$0
      """,
    },
    "/usr/bin/env": {
      "prefix": "env",
      "body": """
      #!/usr/bin/env ${1:zsh}$0
      """,
    },
  },


  ".source.shell": {
    "for item in var": {
      "prefix": "fori",
      "body": """
      for ${1:item} in ${2:var}; do
        ${3:}
      done$0
      """,
    },

    "command options": {
      "prefix": "opts",
      "body": """
      # Extract command options and arguments
      declare -A command_opts=()
      declare -a command_args=()
      while [[ -n \\$1 ]]; do
        local arg_val="\\$(echo \\$1 | sed 's/^[\\\\ ]+//g' | sed 's/[\\\\ ]+\\$//g')"

        case \\$arg_val in
          --foobar ) command_opts["--foobar"]="\\${arg_val\\}" ;;
          * ) command_args+="\\${arg_val\\}" ;;
        esac

        shift
      done$0
      """,
    },

    # "command options": {
    #   "prefix": "opts",
    #   "body": """
    #   declare -A command_options=()
    #   local command_args=()
    #
    #   for item in \\$*; do
    #     local command_option=\\$(is_command_option \\${item\\})
    #
    #     if [[ -n \\$command_option && \\$command_option != "--" ]]; then
    #       option=(\\$(option_value \\${command_option\\}))
    #       command_options[\\${option[1]\\}]=\\${option[2]\\}
    #     else
    #       if [[ \\$command_option != "--" ]]; then
    #         command_args+=\\${item\\}
    #       fi
    #     fi
    #   done$0
    #   """,
    # },
    "while...file": {
      "prefix": "while-readfile",
      "body": """
      # Set the Internal Field Separator to an octothorpe '#'
      IFS="#"
      # Set input file name here
      INPUT="bad-guys.ips.txt"
      # Read file line-by-line to get an IP and comment to block it using the iptables
      while read -r ip comment
      do
      	/sbin/iptables -A INPUT -s "$ip" -m comment --comment "$comment" -j DROP
      done < "$INPUT"$0
      """,
    },
    "while...read": {
      "prefix": "while-read",
      "body": """
      # Set input file name here
      ${4:INPUT}="${1:file}"
      # Read file line-by-line to get an IP and comment to block it using the iptables
      while read -r ${2:line}; do
        ${3:}
      done < "\\$${4:INPUT}"$0
      """,
    },
  },
}
